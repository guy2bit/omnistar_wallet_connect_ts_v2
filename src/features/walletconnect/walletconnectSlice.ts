import { 
  // createAsyncThunk, 
  createSlice, 
  PayloadAction 
} from '@reduxjs/toolkit';
import { SignClient } from '@walletconnect/sign-client/dist/types/client';
import { 
  RootState, 
  // AppThunk 
} from '../../app/store';
import { SessionTypes } from "@walletconnect/types/dist/types/sign-client/session";

export type walletconnectStatus = 'initial' | 'loading' | 'connected' | 'disconnected' | 'failed';

export interface walletconnectState {
  client: SignClient | undefined;
  session: SessionTypes.Struct | undefined;
  address: string | undefined;
  pubkey: Uint8Array | undefined;
  status: walletconnectStatus;
  loadingMsg: string; 
}

const initialState: walletconnectState = {
  client: undefined,
  session: undefined,
  address: undefined,
  pubkey: undefined,
  status: 'initial',
  loadingMsg: 'Please wait...'
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   'walletconnect/fetchCount',
//   async (amount: number) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

class LSWrapper {
  static prefix = 'WC_';
  
  protected static _key = (k: string) => `${LSWrapper.prefix}${k}`;
  
  static setItem(key: string, value: any){
    localStorage.setItem(LSWrapper._key(key), JSON.stringify(value));
  }
  static getItem(key: string): any {
    const res = localStorage.getItem(LSWrapper._key(key));
    return res!=null ? JSON.parse(res) : undefined;
  }
  static removeItem(key: string){
    localStorage.removeItem(LSWrapper._key(key));
  }
}

export const walletconnectSlice = createSlice({
  name: 'walletconnect',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setClient: (state, action: PayloadAction<SignClient>) => {
      state.client = action.payload;
    },
    setSession: (state, action: PayloadAction<SessionTypes.Struct>) => {
      state.session = action.payload;
      LSWrapper.setItem('session', action.payload);
    },
    setAddress: (state, action: PayloadAction<string>) => {
      state.address = action.payload;
      LSWrapper.setItem('address', action.payload);
    },
    setPubkey: (state, action: PayloadAction<Uint8Array>) => {
      state.pubkey = action.payload;
      LSWrapper.setItem('pubkey', Buffer.from(action.payload).toString("hex"));
    },
    setFromCach: (state) => {
      for(let key of ['session', 'address'])
        state[key as keyof walletconnectState] = LSWrapper.getItem(key);
      let _pubkey = LSWrapper.getItem('pubkey');
      state.pubkey = _pubkey ? Uint8Array.from(Buffer.from(_pubkey, "hex")) : undefined;
    },
    setStatus: (state, action: PayloadAction<walletconnectStatus>)=>{
      state.status = action.payload;
      if(action.payload === 'initial'){// after close loading, reset the msg.
        state.loadingMsg = initialState.loadingMsg;
      }
    },
    setLoadingMsg: (state, action: PayloadAction<string>) => {
      state.loadingMsg = action.payload;
    },
    reset: (state) => {
      state.address = undefined;
      state.pubkey = undefined;
      state.session = undefined;
      state.status = "disconnected";
      state.loadingMsg = initialState.loadingMsg;
      for(let key of ['session', 'address', 'pubkey']) 
        LSWrapper.removeItem(key);
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    // builder
    //   .addCase(createClient. .pending, (state) => {
    //     state.status = 'loading';
    //   })
    //   .addCase(createClient .fulfilled, (state, action: PayloadAction<SessionTypes.Struct>) => {
    //     state.status = 'connected';
    //     state.session = action.payload;
    //   })
    //   .addCase(createClient .rejected, (state) => {
    //     state.status = 'failed';
    //   });
  },
});

export const { setLoadingMsg, setStatus, setClient, setSession, setAddress, setPubkey, reset, setFromCach } = walletconnectSlice.actions;

export const selectAddress = (state: RootState) => state.walletconnect.address;
export const selectClient = (state: RootState) => state.walletconnect.client;
export const selectSession = (state: RootState) => state.walletconnect.session;
export const selectPubkey = (state: RootState) => state.walletconnect.pubkey;
export const selectStatus = (state: RootState) => state.walletconnect.status;
export const selectLoadingMsg = (state: RootState) => state.walletconnect.loadingMsg;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState());
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount));
//     }
//   };

export default walletconnectSlice.reducer;
